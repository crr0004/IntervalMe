Index: app/src/main/java/io/github/crr0004/intervalme/views/IntervalClockView.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.github.crr0004.intervalme.views\n\nimport android.content.Context\nimport android.graphics.*\nimport android.os.Build\nimport android.os.Handler\nimport android.util.AttributeSet\nimport android.util.DisplayMetrics\nimport android.view.View\nimport android.view.WindowManager\nimport io.github.crr0004.intervalme.R\nimport java.lang.UnsupportedOperationException\nimport java.util.concurrent.TimeUnit\n\n\nclass IntervalClockView(context: Context?, attrs: AttributeSet?) : android.support.v7.widget.AppCompatImageView(context, attrs) {\n\n\n    private var mCirclePaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)\n    private var mOverlayPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)\n    private var mTextPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)\n\n    private val mDisplayMetrics = DisplayMetrics()\n    //The base radius of our circle for the clock\n    private var mCircleSize = 50.0f\n    private var mCenter = PointF(0.0f,0.0f)\n    private var mBounds = RectF()\n    private val mIntervalPaddingDP = 8.0\n    private val mHandler: Handler = Handler()\n\n    var mPercentageComplete = 0.0f\n        set(value) {\n            field = value\n            this.invalidate()\n        }\n\n    private var mClockText: StringBuilder = StringBuilder(8)\n\n    init {\n        (context!!.getSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay.getMetrics(mDisplayMetrics)\n\n        mCirclePaint.color = Color.BLACK\n        mCirclePaint.strokeWidth = 8.0f\n        mCirclePaint.style = Paint.Style.STROKE\n\n        mOverlayPaint.color = Color.BLUE\n        mOverlayPaint.strokeWidth = 16.0f\n        mOverlayPaint.style = Paint.Style.FILL\n\n        mTextPaint.textAlign = Paint.Align.CENTER\n        mTextPaint.textSize = mDisplayMetrics.scaledDensity * 14f\n\n        val a = context.theme.obtainStyledAttributes(\n                attrs,\n                R.styleable.IntervalClock,\n                0, 0)\n\n        try {\n            mCirclePaint.color = a.getColor(R.styleable.IntervalClock_background_clock_colour, Color.BLACK)\n            mCirclePaint.strokeWidth = a.getFloat(R.styleable.IntervalClock_background_clock_stroke_width, 8.0f)\n            mOverlayPaint.color = a.getColor(R.styleable.IntervalClock_overlay_clock_colour, Color.BLUE)\n            mOverlayPaint.strokeWidth = a.getFloat(R.styleable.IntervalClock_overlay_clock_stroke_width, 16.0f)\n\n            mTextPaint.color = a.getColor(R.styleable.IntervalClock_clock_text_colour, Color.BLACK)\n            mTextPaint.textSize = a.getDimension(R.styleable.IntervalClock_clock_text_size, 8.0f)\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                mTextPaint.typeface = a.getFont(R.styleable.IntervalClock_clock_text_typeface)\n            }\n            mClockText.append(a.getText(R.styleable.IntervalClock_clock_text))\n\n        }catch (e: UnsupportedOperationException){\n\n        }finally {\n            a.recycle()\n        }\n\n    }\n\n    /**\n     * @param time Time in milliseconds\n     */\n    fun setClockTime(time: Long){\n        mClockText.replace(0,mClockText.length,String.format(\"%02d:%02d\",\n                TimeUnit.MILLISECONDS.toMinutes(time),\n                TimeUnit.MILLISECONDS.toSeconds(time) -\n                        TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(time))//,\n                //time - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(time))\n        ))\n        this.invalidate()\n    }\n\n\n    /**\n     * This is called during layout when the size of this view has changed. If\n     * you were just added to the view hierarchy, you're called with the old\n     * value of 0.\n     *\n     * @param w Current width of this view.\n     * @param h Current height of this view.\n     * @param oldw Old width of this view.\n     * @param oldh Old height of this view.\n     */\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n\n        (context.getSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay.getMetrics(mDisplayMetrics)\n        val logicalDensity = mDisplayMetrics.density\n        val intervalPaddingPx = Math.ceil((mIntervalPaddingDP * logicalDensity))\n\n        //min so when we are in landscape it uses the smaller value\n        mCircleSize = ((Math.min(w,h)/2) - intervalPaddingPx).toFloat()\n        //Center is in the center of the view\n        mCenter.set((w/2).toFloat(), (h/2).toFloat())\n        mBounds.set(mCenter.x-mCircleSize,mCenter.y-mCircleSize,mCenter.x+mCircleSize,mCenter.y+mCircleSize)\n    }\n\n    override fun onDraw(canvas: Canvas?) {\n        super.onDraw(canvas)\n        //canvas!!.drawCircle((width/2).toFloat(), (height/2).toFloat(), (Math.min(width,height)/2).toFloat(), mCirclePaint)\n        canvas!!.drawArc(mBounds,0.0f, 360f, false, mCirclePaint)\n        //270 so it starts at the top\n        canvas.drawArc(mBounds,270f, 360f * mPercentageComplete, true, mOverlayPaint)\n\n        canvas.drawText(mClockText.toString(),mCenter.x,mCenter.y,mTextPaint)\n\n    }\n\n    /**\n     * @return A handler associated with the thread running the View. This\n     * handler can be used to pump events in the UI events queue.\n     */\n    override fun getHandler(): Handler {\n        return mHandler\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n\n        // Try for a width based on our minimum\n        val minw = paddingLeft + paddingRight + suggestedMinimumWidth\n        val w = View.resolveSizeAndState(minw, widthMeasureSpec, 1)\n\n        // Whatever the width ends up being, ask for a height that would let the pie\n        // get as big as it can\n       // val minh = View.MeasureSpec.getSize(w) + paddingBottom + paddingTop\n        val h = View.resolveSizeAndState(View.MeasureSpec.getSize(w), heightMeasureSpec, 0)\n\n        setMeasuredDimension(w, h)\n\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/io/github/crr0004/intervalme/views/IntervalClockView.kt	(revision 3d2f0bc3e66efa2bd6fa383d20119da70595c31c)
+++ app/src/main/java/io/github/crr0004/intervalme/views/IntervalClockView.kt	(date 1543834663428)
@@ -6,14 +6,14 @@
 import android.os.Handler
 import android.util.AttributeSet
 import android.util.DisplayMetrics
+import android.util.Log
 import android.view.View
 import android.view.WindowManager
 import io.github.crr0004.intervalme.R
-import java.lang.UnsupportedOperationException
 import java.util.concurrent.TimeUnit
 
 
-class IntervalClockView(context: Context?, attrs: AttributeSet?) : android.support.v7.widget.AppCompatImageView(context, attrs) {
+class IntervalClockView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {
 
 
     private var mCirclePaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
@@ -29,10 +29,6 @@
     private val mHandler: Handler = Handler()
 
     var mPercentageComplete = 0.0f
-        set(value) {
-            field = value
-            this.invalidate()
-        }
 
     private var mClockText: StringBuilder = StringBuilder(8)
 
@@ -87,6 +83,19 @@
                 //time - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(time))
         ))
         this.invalidate()
+        Log.d("ICV", "in setClockTime $time view is attached " + (this.isAttachedToWindow))
+    }
+
+    override fun invalidate() {
+        super.invalidate()
+    }
+
+    override fun isClickable(): Boolean {
+        return true
+    }
+
+    override fun isOpaque(): Boolean {
+        return true
     }
 
 
@@ -112,17 +121,17 @@
         //Center is in the center of the view
         mCenter.set((w/2).toFloat(), (h/2).toFloat())
         mBounds.set(mCenter.x-mCircleSize,mCenter.y-mCircleSize,mCenter.x+mCircleSize,mCenter.y+mCircleSize)
+
     }
 
     override fun onDraw(canvas: Canvas?) {
-        super.onDraw(canvas)
+
         //canvas!!.drawCircle((width/2).toFloat(), (height/2).toFloat(), (Math.min(width,height)/2).toFloat(), mCirclePaint)
         canvas!!.drawArc(mBounds,0.0f, 360f, false, mCirclePaint)
         //270 so it starts at the top
         canvas.drawArc(mBounds,270f, 360f * mPercentageComplete, true, mOverlayPaint)
 
         canvas.drawText(mClockText.toString(),mCenter.x,mCenter.y,mTextPaint)
-
     }
 
     /**
@@ -134,7 +143,7 @@
     }
 
     override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
-        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
+        //super.onMeasure(widthMeasureSpec, heightMeasureSpec)
 
         // Try for a width based on our minimum
         val minw = paddingLeft + paddingRight + suggestedMinimumWidth
Index: app/src/main/java/io/github/crr0004/intervalme/interval/IntervalListAdapter.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.github.crr0004.intervalme.interval\n\nimport android.animation.AnimatorSet\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.support.v7.widget.AppCompatImageButton\nimport android.util.Log\nimport android.util.SparseBooleanArray\nimport android.view.DragEvent\nimport android.view.DragEvent.*\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.view.animation.DecelerateInterpolator\nimport android.widget.*\nimport android.widget.ExpandableListView.getPackedPositionForChild\nimport io.github.crr0004.intervalme.BuildConfig\nimport io.github.crr0004.intervalme.DragDropAnimationController\nimport io.github.crr0004.intervalme.R\nimport io.github.crr0004.intervalme.database.IntervalData\nimport io.github.crr0004.intervalme.database.IntervalRunProperties\nimport io.github.crr0004.intervalme.views.IntervalClockView\nimport java.util.*\n\n\n/**\n * Created by crr00 on 24-Apr-18.\n */\nclass IntervalListAdapter\n        constructor(private val mHostActivity: IntervalListActivity, private val mHost: ExpandableListView):\n        BaseExpandableListAdapter(), DragDropAnimationController.DragDropViewSource<IntervalData>, IntervalControllerFacade.IntervalControllerDataSourceI {\n    // BEGIN IntervalControllerDataSourceI implementation\n    override fun facadeGetIDFromPosition(groupPosition: Int): UUID {\n        return getGroup(groupPosition).group\n    }\n\n    override fun facadeGetGroup(groupPosition: Int): IntervalData {\n        return getGroup(groupPosition)\n    }\n\n    override fun facadeGetGroupSize(groupPosition: Int): Int {\n        return getChildrenCount(groupPosition)\n    }\n\n    override fun facadeGetChild(groupPosition: Int, index: Int): IntervalData {\n        return getChild(groupPosition, index)\n    }\n\n    override fun getGroupProperties(groupPosition: Long): IntervalRunProperties? {\n        return mIntervalProperties[groupPosition]\n    }\n\n    // END IntervalControllerDataSourceI implementation\n\n    //private var mdb: IntervalMeDatabase? = null\n    //private var mIntervalDao: IntervalDataDAO? = null\n   // val mCachedControllers: HashMap<Long, IntervalController> = HashMap()\n    val mChecked = SparseBooleanArray()\n    var mInEditMode: Boolean = false\n    private var mIntervalsList: HashMap<Long, Array<IntervalData>>? = HashMap(10)\n    private var mIntervalProperties: HashMap<Long, IntervalRunProperties> = HashMap(1)\n    private val mNotFoundGroupLabel: String = mHostActivity.getString(R.string.group_not_found_label).toString()\n    private var mGroupSize: Int = 0\n    var groupSize: Int\n        get() {return mGroupSize}\n        set(value) {mGroupSize = value}\n\n    init {\n        //mdb = IntervalMeDatabase.getInstance(mHostActivity.applicationContext)\n        //mIntervalDao = mdb!!.intervalDataDao()\n        IntervalControllerFacade.instance.setDataSource(this)\n    }\n\n    override fun getAdapter(): ExpandableListAdapter {\n        return this\n    }\n\n    override fun swapItems(item1: IntervalData, item2: IntervalData) {\n        val aPos = item1.groupPosition\n        var bPos = item2.groupPosition\n        val aGroup = item1.group\n        val bGroup = item2.group\n\n        // This is unlikely to happen but ensures one follows the other\n        if(aPos == bPos){\n            bPos++\n        }\n\n        item2.groupPosition = aPos\n        item1.groupPosition = bPos\n\n        item2.group = aGroup\n        item1.group = bGroup\n\n        if(aGroup == bGroup) {\n            IntervalControllerFacade.instance.intervalsSwapped(item1.id, item2.id)\n            //mCachedControllers[item2.id]!!.setNextInterval(mCachedControllers[item1.id])\n        }\n\n        mHostActivity.update(item1)\n        mHostActivity.update(item2)\n\n        this.notifyDataSetChanged()\n    }\n    private val intervalOnDragListener = { v: View, event: DragEvent ->\n        val eventType = event.action\n        val intervalBeingDragged = event.localState as IntervalData\n        v.pivotX = 0f\n        v.pivotY = v.height.toFloat()\n\n        when(eventType){\n            ACTION_DRAG_ENTERED -> {\n                val set = AnimatorSet()\n                set.play(ObjectAnimator.ofFloat(v, View.SCALE_Y,\n                        1f, 0.8f))\n                set.duration = v.resources.getInteger(\n                        android.R.integer.config_mediumAnimTime).toLong()\n                set.interpolator = DecelerateInterpolator()\n                set.start()\n\n                // Invalidate the view to force a redraw in the new tint\n                v.invalidate()\n\n            }\n            ACTION_DRAG_EXITED -> {\n                val set = AnimatorSet()\n                set.play(ObjectAnimator.ofFloat(v, View.SCALE_Y,\n                        0.8f, 1f))\n                set.duration = v.resources.getInteger(\n                        android.R.integer.config_mediumAnimTime).toLong()\n                set.interpolator = DecelerateInterpolator()\n                set.start()\n            }\n            ACTION_DROP -> {\n                val set = AnimatorSet()\n                set.play(ObjectAnimator.ofFloat(v, View.SCALE_Y,\n                        0.8f, 1f))\n                set.duration = v.resources.getInteger(\n                        android.R.integer.config_mediumAnimTime).toLong()\n                set.interpolator = DecelerateInterpolator()\n                set.start()\n\n                val packedPos = mHost.getExpandableListPosition(mHost.getPositionForView(v))\n                val intervalDroppedOn = if(v.id == R.id.interval_group){\n                    val groupPos = ExpandableListView.getPackedPositionGroup(packedPos)\n                    getGroup(groupPos)\n                }else{\n                    val childPos = ExpandableListView.getPackedPositionChild(packedPos)\n                    val groupPos = ExpandableListView.getPackedPositionGroup(packedPos)\n                    getChild(groupPos, childPos)\n                }\n\n                /**\n                 * If the interval being dropped on is a group then we need\n                 * to change the behaviour if the interval being dragged is itself a group\n                 */\n                if(intervalDroppedOn.ownerOfGroup){\n                    val groupUUID = intervalDroppedOn.group\n                    if(intervalBeingDragged.group != groupUUID && !intervalBeingDragged.ownerOfGroup) {\n                        mHostActivity.moveIntervalToGroup(intervalBeingDragged, groupUUID)\n                        mHost.expandGroup(intervalDroppedOn.groupPosition.toInt())\n                    }else if(intervalBeingDragged.ownerOfGroup && intervalDroppedOn.ownerOfGroup){\n                        // We've dropped one group on top of another\n                        mIntervalsList?.clear()\n                        mHostActivity.moveIntervalGroupAboveGroup(intervalBeingDragged, intervalDroppedOn)\n                    }\n                    // We don't want to be able to move a group onto a child\n                }else if(!intervalBeingDragged.ownerOfGroup){\n\n                    mHostActivity.moveChildIntervalAboveChild(intervalBeingDragged, intervalDroppedOn)\n                }else{\n                    if(BuildConfig.DEBUG){\n                        Toast.makeText(mHostActivity, \"Undefined behaviour\", Toast.LENGTH_SHORT).show()\n                    }\n                }\n                // this.notifyDataSetChanged()\n                //swapItems(interval, intervalData)\n            }\n            ACTION_DRAG_ENDED -> {\n                if(v.scaleY < 1f){\n                    val set = AnimatorSet()\n                    set.play(ObjectAnimator.ofFloat(v, View.SCALE_Y,\n                            0.8f, 1f))\n                    set.duration = v.resources.getInteger(\n                            android.R.integer.config_mediumAnimTime).toLong()\n                    set.interpolator = DecelerateInterpolator()\n                    set.start()\n                }\n                v.invalidate()\n            }\n            else -> {\n\n            }\n\n        }\n        true\n    }\n\n    fun setProperty(intervalId: Long, property: IntervalRunProperties){\n        mIntervalProperties[intervalId] = property\n    }\n\n    override fun getGroup(groupPosition: Int): IntervalData {\n        var group = mIntervalsList!![groupPosition.toLong()]?.get(0)\n        if(group == null){\n            //group = mIntervalsList!!.value.toList()[0][0]\n            group = IntervalData.generate(1)[0]!!\n            group.label = \"\"\n            //group.groupPosition = groupPosition.toLong()\n            //group.label = group.label + \" \" + group.groupPosition\n            if(BuildConfig.DEBUG) {\n                val errorInfo = StringBuilder(65)\n                errorInfo\n                        .append(\"getGroup hit a null at \")\n                        .append(groupPosition)\n                        .append(\" list size is: \")\n                        .append(mIntervalsList?.size)\n                        .append(\" value at pos is: \")\n                        .append(mIntervalsList!![groupPosition.toLong()])\n                errorInfo.trimToSize()\n                Log.d(\"ILA\", errorInfo.toString())\n            }\n        }\n        return group\n    }\n\n    private fun getProperties(id: Long): IntervalRunProperties?{\n        return mIntervalProperties[id]\n    }\n\n    override fun isChildSelectable(groupPosition: Int, childPosition: Int): Boolean {\n        return true\n    }\n\n\n    override fun hasStableIds(): Boolean {\n        //The ids of the data will be not be consistent across changes\n        return true\n    }\n\n    fun clear(){\n        mIntervalsList?.clear()\n    }\n\n    @SuppressLint(\"InflateParams\")\n    override fun getGroupView(groupPosition: Int, isExpanded: Boolean, convertView: View?, parent: ViewGroup?): View {\n        var toReturn: View? = null\n\n\n        //Top null check for cached view\n        if(convertView?.id == R.layout.interval_group)\n            toReturn = convertView\n\n        if (toReturn == null) {\n            val infalInflater = mHostActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater\n            toReturn = infalInflater.inflate(R.layout.interval_group, parent, false)\n        }\n\n        val intervalData = getGroup(groupPosition)\n        toReturn!!.findViewById<TextView>(R.id.intervalGroupNameTxt).text = intervalData.label ?: \"Interval not found\"\n        toReturn.findViewById<TextView>(R.id.intervalGroupPos).text = intervalData.groupPosition.toString()\n        toReturn.setTag(R.id.id_interval_view_interval, intervalData)\n        val editButton = toReturn.findViewById<AppCompatImageButton>(R.id.clockGroupEditButton)\n        val deleteButton = toReturn.findViewById<AppCompatImageButton>(R.id.clockGroupDeleteButton)\n        val properties = getProperties(intervalData.id)\n        if(properties != null){\n            toReturn.findViewById<TextView>(R.id.intervalGroupLoops).text = properties.loops.toString()\n        }else{\n            toReturn.findViewById<TextView>(R.id.intervalGroupLoopsLbl).visibility = View.GONE\n            toReturn.findViewById<TextView>(R.id.intervalGroupLoops).visibility = View.GONE\n        }\n\n        if(mInEditMode){\n            editButton.visibility = View.VISIBLE\n            deleteButton.visibility = View.VISIBLE\n        }else{\n            editButton.visibility = View.INVISIBLE\n            deleteButton.visibility = View.INVISIBLE\n        }\n\n        editButton.setOnClickListener {\n            mHostActivity.launchAddInEditMode(intervalData)\n        }\n        deleteButton.setOnClickListener{\n            mHostActivity.deleteGroupMoveChildrenToETC(intervalData)\n            // We need to remove the last group because this is going to shuffle them all up\n            mIntervalsList!!.remove(mIntervalsList!!.size.toLong()-1)\n            //if(mIntervalsList!!.size == 0){\n                notifyDataSetChanged()\n            //}\n        }\n        toReturn.setOnDragListener(intervalOnDragListener)\n\n\n        IntervalControllerFacade.instance.groupView(groupPosition, toReturn)\n        /*\n        val group = mIntervalsList?.get(groupPosition.toLong())\n        if(group != null) {\n            val groupChildren = group.drop(1).reversed()\n            groupChildren.forEachIndexed { index, childInterval ->\n                var childAboveController: IntervalController? = null\n                if (index > 0) {\n                    val childAbove = groupChildren[index - 1]\n                    childAboveController = mCachedControllers[childAbove.id]\n                }\n                val childController = if (mCachedControllers[childInterval.id] == null) {\n                    IntervalController(null, childInterval, childAboveController, applicationContext = this.mHostActivity.applicationContext, runProperties = getProperties(childInterval.id))\n                } else {\n                    mCachedControllers[childInterval.id]\n                }\n                mCachedControllers[childInterval.id] = childController!!\n            }\n        }\n        */\n\n        return toReturn\n    }\n\n    override fun getChildrenCount(groupPosition: Int): Int {\n        var size = mIntervalsList?.get(groupPosition.toLong())?.size ?: 0\n        // Remove one from size because the first element is the group\n        if(size > 0)\n            size--\n        return size\n    }\n\n    override fun getChild(groupPosition: Int, childPosition: Int): IntervalData {\n        return mIntervalsList!![groupPosition.toLong()]?.get(childPosition+1)!!\n    }\n\n    override fun getGroupId(groupPosition: Int): Long {\n        return getGroup(groupPosition).id\n    }\n\n\n    @SuppressLint(\"InflateParams\")\n    override fun getChildView(groupPosition: Int, childPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup?): View {\n        var toReturn: View? = null\n        val childOfInterval = getChild(groupPosition, childPosition)\n        var previousInterval: IntervalData? = null\n\n        if(childPosition > 0) {\n            previousInterval = getChild(groupPosition, childPosition - 1)\n        }\n\n        //toReturn = mCachedViews[childOfInterval.id]\n\n        //Top null check for cached view\n        if(convertView?.id == R.layout.interval_single_clock)\n            toReturn = convertView\n        // Look for our mController that may have been forward init\n        //var controller: IntervalGroupController? = mGroupControlls[groupPosition.toLong()]!!\n        // If we're using an existing mController we must make sure to release properly before re-init\n\n        // second null check for using a converted view\n        if (toReturn == null) {\n            val inflater = mHostActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater\n            //Passing null as root until I figure it out. Passing parent causes a crash\n            toReturn = inflater.inflate(R.layout.interval_single_clock, null)\n        }\n\n        val clockView = toReturn!!.findViewById<IntervalClockView>(R.id.intervalClockView)\n        val editButton = toReturn.findViewById<AppCompatImageButton>(R.id.clockSingleEditButton)\n        val deleteButton = toReturn.findViewById<AppCompatImageButton>(R.id.clockSingleDeleteButton)\n        val checkBox = toReturn.findViewById<CheckBox>(R.id.clockEditCheckbox)\n        val properties = getProperties(childOfInterval.id)\n        if(properties != null){\n            toReturn.findViewById<TextView>(R.id.clockLoopsTxt).text = properties .loops.toString()\n        }else{\n            toReturn.findViewById<TextView>(R.id.clockLoopsTxt).visibility = View.GONE\n            toReturn.findViewById<TextView>(R.id.clockLabelLoops).visibility = View.GONE\n        }\n\n        toReturn.findViewById<TextView>(R.id.clockLabelTxt)?.text = childOfInterval.label\n        //toReturn.findViewById<TextView>(R.id.clockLabelPos)?.text = childOfInterval.groupPosition.toString()\n\n        if(mInEditMode){\n            toReturn.findViewById<View>(R.id.clockEditCheckbox).visibility = View.VISIBLE\n            toReturn.findViewById<View>(R.id.clockSingleEditButton).visibility = View.VISIBLE\n            toReturn.findViewById<View>(R.id.clockSingleDeleteButton).visibility = View.VISIBLE\n        }else{\n            toReturn.findViewById<View>(R.id.clockEditCheckbox).visibility = View.INVISIBLE\n            toReturn.findViewById<View>(R.id.clockSingleEditButton).visibility = View.INVISIBLE\n            toReturn.findViewById<View>(R.id.clockSingleDeleteButton).visibility = View.INVISIBLE\n        }\n\n\n        toReturn.setOnDragListener(intervalOnDragListener)\n\n        IntervalControllerFacade.instance.connectClockView(clockView, groupPosition, childOfInterval)\n        // Controller hasn't been forward cached so create it\n        //if(controller == null) {\n            //controller = IntervalController(clockView, childOfInterval, applicationContext = this.mHostActivity.applicationContext, runProperties = properties)\n        //}else {\n            // We need to tell the other mController to disconnect from the clock\n            //clockView.mController?.disconnectFromViews()\n            //controller?.disconnectFromViews(childPosition)\n            //controller?.connectNewClockView(clockView, childPosition)\n            //clockView.mController = controller\n        //}\n        // Ensure controller is up to date\n        //controller.mChildOfInterval = childOfInterval\n\n        //if(childPosition > 0)\n            //mCachedControllers[previousInterval!!.id]!!.setNextInterval(controller)\n\n        //mCachedControllers[childOfInterval.id] = controller\n        val flatListPosition = mHost.getFlatListPosition(getPackedPositionForChild(groupPosition, childPosition))\n        checkBox.setOnClickListener {\n            setItemChecked(flatListPosition, checkBox.isChecked)\n            //mChecked.put(flatListPosition, checkBox.isChecked)\n            //Log.d(\"ILA\", \"Checked: \" + checkBox.isChecked)\n            //checkBox.toggle()\n        }\n        checkBox.isChecked = mChecked.get(flatListPosition, false)\n\n        editButton.setOnClickListener {\n            mHostActivity.launchAddInEditMode(childOfInterval)\n        }\n        deleteButton.setOnClickListener {\n            mHostActivity.deleteChild(childOfInterval)\n            notifyDataSetChanged()\n        }\n        // Ensures when we move items around, the next intervals are getting updated\n        if(isLastChild){\n            //controller.setNextInterval(null)\n            IntervalControllerFacade.instance.setIntervalAsLast(groupPosition, childOfInterval)\n        }\n\n        return toReturn\n    }\n\n    override fun getChildId(groupPosition: Int, childPosition: Int): Long {\n        val childOfInterval = getChild(groupPosition,childPosition)\n        return childOfInterval.id\n    }\n\n    override fun getGroupCount(): Int {\n        return mIntervalsList?.size ?: 0\n    }\n\n    fun startAllIntervals() {\n        IntervalControllerFacade.instance.startAllIntervals()\n        //mCachedControllers.forEach { _, controller ->\n            //controller.startClockAsNew()\n        //}\n    }\n\n    fun setItemChecked(keyAt: Int, b: Boolean) {\n        if(b) {\n            mChecked.put(keyAt, b)\n        }else{\n            mChecked.delete(keyAt)\n        }\n    }\n\n    //private var mGroupControlls: HashMap<Long, IntervalGroupController?> = HashMap(1)\n\n    fun setGroup(groupPosition: Long, it: Array<IntervalData>) {\n        mIntervalsList!![groupPosition] = it\n        IntervalControllerFacade.instance.setUpGroupOrder(it[0].groupPosition.toInt(), mHostActivity)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/io/github/crr0004/intervalme/interval/IntervalListAdapter.kt	(revision 3d2f0bc3e66efa2bd6fa383d20119da70595c31c)
+++ app/src/main/java/io/github/crr0004/intervalme/interval/IntervalListAdapter.kt	(date 1543834638799)
@@ -334,30 +334,21 @@
     }
 
 
-    @SuppressLint("InflateParams")
     override fun getChildView(groupPosition: Int, childPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup?): View {
         var toReturn: View? = null
         val childOfInterval = getChild(groupPosition, childPosition)
-        var previousInterval: IntervalData? = null
-
-        if(childPosition > 0) {
-            previousInterval = getChild(groupPosition, childPosition - 1)
-        }
 
         //toReturn = mCachedViews[childOfInterval.id]
 
         //Top null check for cached view
         if(convertView?.id == R.layout.interval_single_clock)
             toReturn = convertView
-        // Look for our mController that may have been forward init
-        //var controller: IntervalGroupController? = mGroupControlls[groupPosition.toLong()]!!
-        // If we're using an existing mController we must make sure to release properly before re-init
 
         // second null check for using a converted view
         if (toReturn == null) {
             val inflater = mHostActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
-            //Passing null as root until I figure it out. Passing parent causes a crash
-            toReturn = inflater.inflate(R.layout.interval_single_clock, null)
+            toReturn = inflater.inflate(R.layout.interval_single_clock, parent, false)
+            Log.d("ILA", "Inflating new single clock layout")
         }
 
         val clockView = toReturn!!.findViewById<IntervalClockView>(R.id.intervalClockView)
@@ -366,7 +357,7 @@
         val checkBox = toReturn.findViewById<CheckBox>(R.id.clockEditCheckbox)
         val properties = getProperties(childOfInterval.id)
         if(properties != null){
-            toReturn.findViewById<TextView>(R.id.clockLoopsTxt).text = properties .loops.toString()
+            toReturn.findViewById<TextView>(R.id.clockLoopsTxt).text = properties.loops.toString()
         }else{
             toReturn.findViewById<TextView>(R.id.clockLoopsTxt).visibility = View.GONE
             toReturn.findViewById<TextView>(R.id.clockLabelLoops).visibility = View.GONE
@@ -389,23 +380,7 @@
         toReturn.setOnDragListener(intervalOnDragListener)
 
         IntervalControllerFacade.instance.connectClockView(clockView, groupPosition, childOfInterval)
-        // Controller hasn't been forward cached so create it
-        //if(controller == null) {
-            //controller = IntervalController(clockView, childOfInterval, applicationContext = this.mHostActivity.applicationContext, runProperties = properties)
-        //}else {
-            // We need to tell the other mController to disconnect from the clock
-            //clockView.mController?.disconnectFromViews()
-            //controller?.disconnectFromViews(childPosition)
-            //controller?.connectNewClockView(clockView, childPosition)
-            //clockView.mController = controller
-        //}
-        // Ensure controller is up to date
-        //controller.mChildOfInterval = childOfInterval
 
-        //if(childPosition > 0)
-            //mCachedControllers[previousInterval!!.id]!!.setNextInterval(controller)
-
-        //mCachedControllers[childOfInterval.id] = controller
         val flatListPosition = mHost.getFlatListPosition(getPackedPositionForChild(groupPosition, childPosition))
         checkBox.setOnClickListener {
             setItemChecked(flatListPosition, checkBox.isChecked)
@@ -431,11 +406,15 @@
         return toReturn
     }
 
+
+
     override fun getChildId(groupPosition: Int, childPosition: Int): Long {
         val childOfInterval = getChild(groupPosition,childPosition)
         return childOfInterval.id
     }
 
+
+
     override fun getGroupCount(): Int {
         return mIntervalsList?.size ?: 0
     }
Index: app/src/main/java/io/github/crr0004/intervalme/interval/IntervalController.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.github.crr0004.intervalme.interval\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.os.Handler\nimport android.os.SystemClock\nimport android.support.v4.view.GestureDetectorCompat\nimport android.util.Log\nimport android.view.GestureDetector\nimport android.view.MotionEvent\nimport android.view.View\nimport io.github.crr0004.intervalme.R\nimport io.github.crr0004.intervalme.database.IntervalData\nimport io.github.crr0004.intervalme.database.IntervalRunProperties\nimport io.github.crr0004.intervalme.views.IntervalClockView\nimport java.util.concurrent.TimeUnit\n\n\n/**\n * A mController for dealing with the logic between the IntervalClockView and a data source\n */\n// We can suppress this because we ensure click logic is in onClickListener\n@SuppressLint(\"ClickableViewAccessibility\")\nopen class IntervalController\n/**\n * @param mClockView the view that this mController uses\n * @param mChildOfInterval the interval data from the db\n */(mClockView: IntervalClockView? = null, mChildOfInterval: IntervalData, runProperties: IntervalRunProperties? = null, applicationContext: Context? = null, callBackHost: IntervalControllerCallBackI) : GestureDetector.SimpleOnGestureListener() {\n\n    private var mClockRunning = false\n    companion object {\n        const val DEBUG_TAG = \"ICGestures\"\n    }\n    private lateinit var mDetector: GestureDetectorCompat\n    private lateinit var mClockTickRunnable: TickClockRunnable\n    private var mCallBackHost: IntervalControllerCallBackI = callBackHost\n\n    interface IntervalControllerCallBackI {\n        fun clockStartedAsNew(intervalController: IntervalController)\n        fun clockResumedFromPause(intervalController: IntervalController)\n        fun clockPaused(intervalController: IntervalController)\n        fun clockFinished(intervalController: IntervalController, mSoundController: IntervalSoundController?)\n        fun clockStopped(intervalController: IntervalController)\n        fun clockTimeUpdatedTo(intervalController: IntervalController, mTimeToRun: Long)\n\n    }\n\n    private var mClockView: IntervalClockView? = null\n    lateinit var mChildOfInterval: IntervalData\n    private var mIntervalProperties: IntervalRunProperties? = null\n    //private var mNextInterval: IntervalController? = null\n    private var mSoundController: IntervalSoundController? = null\n    private var mThread: Thread? = null\n\n    init {\n        init(mClockView, mChildOfInterval, runProperties = runProperties, applicationContext = applicationContext)\n    }\n\n    private fun init(\n            clockView: IntervalClockView?,\n            childOfInterval: IntervalData,\n            applicationContext: Context? = null,\n            runProperties: IntervalRunProperties? = null) {\n        mClockView = clockView\n        mChildOfInterval = childOfInterval\n        mDetector = GestureDetectorCompat(applicationContext, this)\n        mIntervalProperties = runProperties\n\n\n\n        mClockView?.setOnTouchListener { _, event ->\n            mDetector.onTouchEvent(event)\n        }\n\n        // We do this so accessibility has correct logic\n        mClockView?.setOnClickListener {\n            clickOnClock()\n        }\n        mClockView?.setClockTime(TimeUnit.SECONDS.toMillis(childOfInterval.duration))\n            mClockTickRunnable = TickClockRunnable(mClockView, TimeUnit.SECONDS.toMillis(childOfInterval.duration), this)\n        if (childOfInterval.runningDuration > 0) {\n            mClockTickRunnable.mTimeToRun = childOfInterval.runningDuration\n            mClockView?.setClockTime(mClockTickRunnable.mTimeToRun)\n        }\n        //Only create new sound mController if it's been previously released\n        if(mSoundController == null && applicationContext != null)\n            mSoundController = IntervalSoundController.instanceWith(applicationContext.applicationContext, R.raw.digital_watch_alarm_1)\n    }\n\n    private fun clickOnClock(){\n        if(!mClockRunning) {\n            startClockAsNew()\n        }else{\n            // The clock has already been started so now we just invert the runnable\n            mClockTickRunnable.mRunning = !mClockTickRunnable.mRunning\n            if(mClockTickRunnable.mRunning){\n                // The clock was paused so we need to start it again\n                // We also move the clock ahead to the current time minus however much time has passed\n                mClockTickRunnable.mStartingTime = SystemClock.elapsedRealtime() - mClockTickRunnable.mElapsedTime\n                // mClockView!!.post(mClockTickRunnable)\n                mCallBackHost.clockResumedFromPause(this)\n            }else{\n                mThread?.interrupt()\n                mCallBackHost.clockPaused(this)\n            }\n            startClockThread()\n        }\n    }\n\n    /* This may still be needed in the future\n    open fun disconnectFromViews(){\n        mClockView?.setOnTouchListener(null)\n        mClockTickRunnable.releaseClockView()\n    }\n    */\n\n    override fun onSingleTapConfirmed(e: MotionEvent?): Boolean {\n        // We've started the clock for the first time\n        mClockView?.performClick()\n        return true\n    }\n\n    @Synchronized\n    private fun startClockThread(){\n        mThread = Thread(mClockTickRunnable, mChildOfInterval.label)\n        try {\n            mThread?.start()\n        }catch (e: IllegalThreadStateException){\n            Log.d(DEBUG_TAG, \"Tried to start a bad thread\")\n        }\n    }\n\n    fun startClockAsNew() {\n        stopAndRefreshClock()\n        mClockTickRunnable.mRunning = true\n        startClockThread()\n        mClockRunning = true\n        mCallBackHost.clockStartedAsNew(this)\n    }\n\n    override fun onDoubleTap(e: MotionEvent?): Boolean {\n        // We stop the clock\n        stopAndRefreshClock()\n        mClockView?.mPercentageComplete = 0f\n        mClockView?.setClockTime(mClockTickRunnable.mTimeToRun)\n\n        return true\n    }\n\n    open fun stopAndRefreshClock() {\n        mClockRunning = false\n        mClockTickRunnable.mRunning = false\n        mClockTickRunnable.reset()\n        mThread?.interrupt()\n\n        mClockTickRunnable.mTimeToRun = TimeUnit.SECONDS.toMillis(mChildOfInterval.duration)\n        mCallBackHost.clockStopped(this)\n\n        //mClockView?.setClockTime(mClockTickRunnable.mTimeToRun)\n    }\n\n    override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean {\n        /*\n        mClockTickRunnable.mTimeToRun -= distanceX.toLong() * 100\n        mClockView!!.setClockTime(mClockTickRunnable.mTimeToRun)\n        if(mClockRunning) {\n            mClockTickRunnable.updatePercentComplete()\n        }\n        mCallBackHost.clockTimeUpdatedTo(this, mClockTickRunnable.mTimeToRun)\n        */\n        return false\n    }\n\n    override fun onDown(e: MotionEvent?): Boolean {\n        return true\n    }\n\n    /**\n     * Called when the timer has finished and the next one is to begin\n     */\n    private fun finishedTimer() {\n        mClockRunning = false\n\n        //Log.d(DEBUG_TAG, \"IntervalController $mChildOfInterval done\")\n\n        mCallBackHost.clockFinished(this, mSoundController)\n    }\n\n    open fun connectNewClockView(view: View) {\n        if(view.id == R.id.intervalClockView) {\n            mClockView = view as IntervalClockView\n\n            mClockTickRunnable.connectNewClock(view)\n            mClockView!!.setOnTouchListener { _, event ->\n                mDetector.onTouchEvent(event)\n            }\n            mClockView!!.setOnClickListener {\n                clickOnClock()\n            }\n        }\n\n\n    }\n\n    open fun updateViewToProperties(properties: IntervalRunProperties) {\n        // this currently doesn't do anything for child view\n    }\n\n    private class TickClockRunnable(\n            @get:Synchronized @set:Synchronized\n            var mClockView: IntervalClockView?,\n            @get:Synchronized @set:Synchronized\n            var mTimeToRun: Long,\n            private val mIntervalController: IntervalController) : Runnable{\n\n        @get:Synchronized @set:Synchronized\n        var mStartingTime = SystemClock.elapsedRealtime()\n\n        @get:Synchronized @set:Synchronized\n        var mElapsedTime = 0L\n\n        @get:Synchronized @set:Synchronized\n        var mRunning: Boolean = true\n\n        private var mUpdateClockHandler: Handler? = null\n\n        private val updateClock = Runnable{\n            updatePercentComplete()\n            if(mTimeToRun - mElapsedTime > 100f) {\n                mClockView?.setClockTime(mTimeToRun - mElapsedTime)\n            }else{\n                mClockView?.setClockTime(0)\n            }\n        }\n\n        fun connectNewClock(clockView: IntervalClockView){\n            mClockView = clockView\n            mClockView?.setClockTime(mTimeToRun - mElapsedTime)\n            updatePercentComplete()\n            mUpdateClockHandler = mClockView?.handler\n\n        }\n\n        override fun run() {\n            while(mRunning) {\n                mElapsedTime = SystemClock.elapsedRealtime() - mStartingTime\n                if (mTimeToRun - mElapsedTime >= 100f && mRunning) {\n                    mUpdateClockHandler?.post(updateClock)\n                    try {\n                        Thread.sleep(33)\n                    }catch(e: InterruptedException){\n\n                    }\n                } else if (mRunning) {\n                    mUpdateClockHandler?.post(updateClock)\n                    mIntervalController.finishedTimer()\n                    mRunning = false\n                }\n            }\n\n        }\n        fun reset(){\n            mStartingTime = SystemClock.elapsedRealtime()\n            mElapsedTime = 0\n        }\n        @Synchronized\n        fun updatePercentComplete(){\n            if(mTimeToRun - mElapsedTime >= 100f) {\n                mClockView?.mPercentageComplete = mElapsedTime.toFloat() / mTimeToRun\n            }else{\n                mClockView?.mPercentageComplete = 1f\n            }\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/io/github/crr0004/intervalme/interval/IntervalController.kt	(revision 3d2f0bc3e66efa2bd6fa383d20119da70595c31c)
+++ app/src/main/java/io/github/crr0004/intervalme/interval/IntervalController.kt	(date 1543834638745)
@@ -154,7 +154,7 @@
         mThread?.interrupt()
 
         mClockTickRunnable.mTimeToRun = TimeUnit.SECONDS.toMillis(mChildOfInterval.duration)
-        mCallBackHost.clockStopped(this)
+        //mCallBackHost.clockStopped(this)
 
         //mClockView?.setClockTime(mClockTickRunnable.mTimeToRun)
     }
@@ -187,9 +187,18 @@
     }
 
     open fun connectNewClockView(view: View) {
+        val attached = mClockView?.isAttachedToWindow ?: false
+        Log.d("IC", "Connecting " + Integer.toHexString(System.identityHashCode(view)) + " is attached $attached")
         if(view.id == R.id.intervalClockView) {
+
+            mClockView?.setOnTouchListener(null)
+            mClockView?.setOnClickListener(null)
+            mClockView?.mPercentageComplete = 0f
+            mClockView?.setClockTime(0)
+
             mClockView = view as IntervalClockView
 
+
             mClockTickRunnable.connectNewClock(view)
             mClockView!!.setOnTouchListener { _, event ->
                 mDetector.onTouchEvent(event)
@@ -230,14 +239,16 @@
                 mClockView?.setClockTime(mTimeToRun - mElapsedTime)
             }else{
                 mClockView?.setClockTime(0)
+                //mUpdateClockHandler?.removeCallbacks(this)
             }
         }
 
         fun connectNewClock(clockView: IntervalClockView){
+            mUpdateClockHandler?.removeCallbacks(updateClock)
             mClockView = clockView
-            mClockView?.setClockTime(mTimeToRun - mElapsedTime)
             updatePercentComplete()
-            mUpdateClockHandler = mClockView?.handler
+            mUpdateClockHandler = mClockView!!.handler
+            mClockView!!.setClockTime(mTimeToRun - mElapsedTime)
 
         }
 
@@ -252,6 +263,7 @@
 
                     }
                 } else if (mRunning) {
+                    //mUpdateClockHandler?.removeCallbacks(updateClock)
                     mUpdateClockHandler?.post(updateClock)
                     mIntervalController.finishedTimer()
                     mRunning = false
@@ -263,7 +275,7 @@
             mStartingTime = SystemClock.elapsedRealtime()
             mElapsedTime = 0
         }
-        @Synchronized
+
         fun updatePercentComplete(){
             if(mTimeToRun - mElapsedTime >= 100f) {
                 mClockView?.mPercentageComplete = mElapsedTime.toFloat() / mTimeToRun
